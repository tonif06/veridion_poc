# Power BI Measures (with Explanations)
**Model table:** `matches_decisions` (loaded from `output/matches_decisions.csv`).  
Copy–paste these DAX measures into your model. Group them into folders for clarity.

---

## COUNTS

### 1) Total Rows
```DAX
Total Rows = COUNTROWS(matches_decisions)
```
**What it is:** total number of resolved records (one per input row, best candidate kept).  
**Use in visuals:** KPI card, denominators for % measures.  
**Edge cases:** if you filter by country/city, this updates accordingly.

### 2) Matched Rows
```DAX
Matched Rows =
    CALCULATE(COUNTROWS(matches_decisions), matches_decisions[decision] = "Matched")
```
**What it is:** rows confidently matched by rules/score.  
**Use:** KPI card; donut/stacked visuals by decision.  
**Tip:** combine with geographic slicers to show match coverage by region.

### 3) Needs Review Rows
```DAX
Needs Review Rows =
    CALCULATE(COUNTROWS(matches_decisions), matches_decisions[decision] = "Needs Review")
```
**What it is:** rows in the manual review queue.  
**Use:** Review page KPIs; filter the review table to prioritize work.

### 4) Unmatched Rows
```DAX
Unmatched Rows =
    CALCULATE(COUNTROWS(matches_decisions), matches_decisions[decision] = "Unmatched")
```
**What it is:** rows we could not match.  
**Use:** KPI; track improvements after tuning weights/thresholds.

### 5) Distinct Matched Companies
```DAX
Distinct Matched Companies =
    CALCULATE(DISTINCTCOUNT(matches_decisions[veridion_id]), matches_decisions[decision] = "Matched")
```
**What it is:** distinct real-world entities covered by confident matches.  
**Use:** KPI for unique coverage, not just rows.

---

## PERCENTAGES

### 6) Matched %
```DAX
Matched % =
    DIVIDE([Matched Rows], [Total Rows])
```
**What it is:** share of Matched among all rows.  
**Use:** KPI card; target threshold for exec summary.  
**Edge cases:** if `Total Rows` can be 0, `DIVIDE` avoids divide-by-zero.

### 7) Needs Review %
```DAX
Needs Review % =
    DIVIDE([Needs Review Rows], [Total Rows])
```
**What it is:** share of rows requiring manual action.  
**Use:** operational KPI; the lower, the better.

### 8) Unmatched %
```DAX
Unmatched % =
    DIVIDE([Unmatched Rows], [Total Rows])
```
**What it is:** share of rows not confidently matched.  
**Use:** watch this when tuning the pipeline.

### 9) Clean %
```DAX
Clean % =
    DIVIDE([Clean Rows], [Total Rows])
```
**What it is:** share of rows with **no** QC flags.  
**Use:** proxy for data quality health.

### 10) Has Flags %
```DAX
Has Flags % =
    DIVIDE([Has Flags Rows], [Total Rows])
```
**What it is:** share of rows with at least one QC flag.  
**Use:** track data debt; aim to reduce over time.

---

## QUALITY SPLIT

### 11) Clean Rows
```DAX
Clean Rows =
    CALCULATE(
        COUNTROWS(matches_decisions),
        ISBLANK(matches_decisions[qc_flags]) || TRIM(matches_decisions[qc_flags]) = ""
    )
```
**What it is:** number of rows without QC flags.  
**Use:** KPI; stacked visuals vs `Has Flags Rows`.  
**Note:** `qc_flags` is a comma-separated text string generated by the pipeline.

### 12) Has Flags Rows
```DAX
Has Flags Rows =
    CALCULATE(
        COUNTROWS(matches_decisions),
        NOT(ISBLANK(matches_decisions[qc_flags]) || TRIM(matches_decisions[qc_flags]) = "")
    )
```
**What it is:** rows with at least one QC flag.  
**Use:** to quantify issues; drive cleanup work.

---

## SCORES & SIMILARITIES

### 13) Average Match Score
```DAX
Average Match Score = AVERAGE(matches_decisions[match_score])
```
**What it is:** mean weighted score across rows.  
**Use:** track overall matching quality.

### 14) Max Match Score
```DAX
Max Match Score = MAX(matches_decisions[match_score])
```
**What it is:** top score in context (useful with slicers).

### 15) Min Match Score
```DAX
Min Match Score = MIN(matches_decisions[match_score])
```
**What it is:** lowest score in context (spot weak areas).

### 16) Average Name Similarity
```DAX
Average Name Similarity = AVERAGE(matches_decisions[name_similarity])
```
**What it is:** mean raw name similarity (0–1).  
**Use:** diagnose if low naming similarities drive mismatches.

### 17) Average Freshness
```DAX
Average Freshness = AVERAGE(matches_decisions[freshness])
```
**What it is:** mean freshness score (higher = more recent data).  
**Use:** show how up-to-date the matched data is.

---

## FEATURE PRESENCE (BINARY COLUMNS)

### 18) Website Present Rows
```DAX
Website Present Rows =
    CALCULATE(COUNTROWS(matches_decisions), matches_decisions[has_website] = 1)
```
**What it is:** rows with a website detected.  
**Use:** coverage KPI for web presence.

### 19) Website Present %
```DAX
Website Present % =
    DIVIDE([Website Present Rows], [Total Rows])
```
**What it is:** share with website present (good proxy for digital presence).

### 20) Country Match Rows
```DAX
Country Match Rows =
    CALCULATE(COUNTROWS(matches_decisions), matches_decisions[country_match] = 1)
```
**What it is:** rows where input country matches candidate country.  
**Use:** quick signal of geographic alignment.

### 21) Country Match %
```DAX
Country Match % =
    DIVIDE([Country Match Rows], [Total Rows])
```
**What it is:** proportion with country match.

### 22) City Match Rows
```DAX
City Match Rows =
    CALCULATE(COUNTROWS(matches_decisions), matches_decisions[city_match] = 1)
```
**What it is:** rows where city matched exactly (normalized).  
**Use:** more granular geo alignment signal.

### 23) City Match %
```DAX
City Match % =
    DIVIDE([City Match Rows], [Total Rows])
```
**What it is:** proportion with city match.

---

## QC FLAG BREAKDOWN (TEXT SEARCH IN `qc_flags`)

### 24) Flag: Missing Postcode
```DAX
Flag: Missing Postcode =
    CALCULATE(
        COUNTROWS(matches_decisions),
        NOT(ISBLANK(matches_decisions[qc_flags])),
        CONTAINSSTRING(matches_decisions[qc_flags], "missing_postcode")
    )
```
**What it is:** count of rows where postcode is missing.  
**Use:** address addressing info gaps.

### 25) Flag: Missing Street
```DAX
Flag: Missing Street =
    CALCULATE(
        COUNTROWS(matches_decisions),
        NOT(ISBLANK(matches_decisions[qc_flags])),
        CONTAINSSTRING(matches_decisions[qc_flags], "missing_street")
    )
```
**What it is:** count of rows where street is missing.

### 26) Flag: No Website / No Social
```DAX
Flag: No Website / No Social =
    CALCULATE(
        COUNTROWS(matches_decisions),
        NOT(ISBLANK(matches_decisions[qc_flags])),
        CONTAINSSTRING(matches_decisions[qc_flags], "no_website_no_social")
    )
```
**What it is:** neither website nor social detected.  
**Use:** prioritize enrichment.

### 27) Flag: Stale > 2y
```DAX
Flag: Stale > 2y =
    CALCULATE(
        COUNTROWS(matches_decisions),
        NOT(ISBLANK(matches_decisions[qc_flags])),
        CONTAINSSTRING(matches_decisions[qc_flags], "stale_update_>2y")
    )
```
**What it is:** “last update” older than two years.

### 28) Flag: Missing Company Type
```DAX
Flag: Missing Company Type =
    CALCULATE(
        COUNTROWS(matches_decisions),
        NOT(ISBLANK(matches_decisions[qc_flags])),
        CONTAINSSTRING(matches_decisions[qc_flags], "missing_company_type")
    )
```
**What it is:** company_type blank or missing.

### 29) Flags % of Total
```DAX
Flags % of Total =
    DIVIDE([Has Flags Rows], [Total Rows])
```
**What it is:** overall share of flagged rows.

### 30) No Flags % of Total
```DAX
No Flags % of Total =
    DIVIDE([Clean Rows], [Total Rows])
```
**What it is:** the inverse: share of clean rows.

---

## PRACTICAL NOTES
- Replace `matches_decisions` with your actual table name if different.
- Use **Display Folders** to keep measures tidy: *Counts*, *Percentages*, *Quality*, *Scores*, *Features*, *QC Flags*.
- For score distributions, create **numeric bins** on `match_score` and `name_similarity` (Model → New group).
- Recommended colors: Matched=green, Needs Review=amber, Unmatched/Has Flags=red.